# Configuration for Universal Stochastic Predictor

[meta]
# Snapshot versioning for backward compatibility
schema_version = "1.0"

[core]
# JAX configuration
jax_platforms = "cpu"  # Change to "gpu" or "tpu" as needed
jax_default_dtype = "float64"  # Sync with __init__.py (jax_enable_x64 = True)

# Numerical precision
float_precision = 64  # Must match jax_enable_x64 for Malliavin stability

# Latency policies
staleness_ttl_ns = 500_000_000  # TTL: 500ms (degraded mode trigger)

[orchestration]
# JKO Orchestrator (Optimal Transport)
epsilon = 0.001  # Entropic regularization (Sinkhorn)
learning_rate = 0.01  # JKO learning rate (tau)

# Sinkhorn parameters (dispersion-coupled, see doc/Predictor_Estocastico_Implementacion.tex §2.4)
sinkhorn_epsilon_min = 0.01
sinkhorn_epsilon_0 = 0.1
sinkhorn_alpha = 0.5  # Coupling coefficient to volatility
sinkhorn_max_iter = 200  # Max Sinkhorn iterations (scan length)

# Entropy monitoring
entropy_window = 100
entropy_threshold = 0.8

# CUSUM grace period (in steps, see doc/Predictor_Estocastico_API_Python.tex §3.2)
grace_period_steps = 20
cusum_h = 5.0  # Drift threshold
cusum_k = 0.5  # Slack tolerance
residual_window_size = 252  # Annual rolling window for kurtosis computation

# Volatility monitoring (EWMA)
volatility_alpha = 0.1

# Outlier detection (Black Swan threshold)
sigma_bound = 20.0  # N sigma for catastrophic outlier detection
sigma_val = 1.0  # Reference standard deviation for outlier detection

# Temporal drift validation (clock skew and stale data thresholds)
max_future_drift_ns = 1_000_000_000  # 1 second (future clock skew tolerance)
max_past_drift_ns = 86_400_000_000_000  # 24 hours (stale data threshold)

# Circuit breaker
holder_threshold = 0.4  # Holder exponent critical threshold

# Recovery hysteresis
inference_recovery_hysteresis = 0.8

[kernels]
# Kernel D (Path Signatures - Rough Paths Theory)
log_sig_depth = 3                       # Truncation depth for signature transform (legacy field)
kernel_d_depth = 3                      # Log-signature truncation depth (L)
kernel_d_alpha = 0.1                    # Signature extrapolation scaling factor
kernel_d_confidence_scale = 0.1         # Scaling factor for signature-based confidence
kernel_d_confidence_base = 1.0          # Base factor for confidence (base + sig_norm)

# Base/Validation Parameters
base_min_signal_length = 32             # Minimum required signal length
signal_normalization_method = "zscore"  # Normalization method: 'zscore' or 'minmax'
numerical_epsilon = 1e-10               # Unified stability epsilon (divisions, logs, stiffness)
warmup_signal_length = 100              # Representative signal length for JIT warm-up

# Kernel A (RKHS - Reproducing Kernel Hilbert Space)
wtmm_buffer_size = 128                  # Sliding memory buffer
besov_cone_c = 1.5                      # Besov cone of influence
besov_nyquist_interval_ns = 100_000_000 # Nyquist interval (100ms)
kernel_a_bandwidth = 0.1                # Gaussian kernel bandwidth (smoothness)
kernel_a_embedding_dim = 5              # Time-delay embedding dimension (Takens)
kernel_a_min_variance = 1e-10           # Minimum variance clipping (numerical stability)
kernel_ridge_lambda = 1e-6              # Ridge regularization parameter

# Kernel C (SDE Integration - Levy Process)
# SDE scheme switching stiffness thresholds (Rama C, see doc/Predictor_Estocastico_Teoria.tex §2.3.3)
stiffness_low = 100                     # Below: use explicit Euler-Maruyama
stiffness_high = 1000                   # Above: use implicit trapezial
sde_dt = 0.01                           # Time step
sde_numel_integrations = 100            # Number of integration steps
sde_diffusion_sigma = 0.2               # Diffusion coefficient (Levy process volatility)
kernel_c_mu = 0.0                       # Drift (mean reversion rate)
kernel_c_alpha = 1.8                    # Stability parameter (1 < alpha <= 2)
kernel_c_beta = 0.0                     # Skewness parameter (-1 <= beta <= 1)
kernel_c_horizon = 1.0                  # Prediction horizon (integration time)
kernel_c_dt0 = 0.01                     # Initial time step (adaptive stepping)
kernel_c_alpha_gaussian_threshold = 1.99  # Gaussian regime threshold (alpha > threshold)

# Phase 6: SDE Solver Hyperparameters (Zero-Heuristics - Kernel C)
sde_brownian_tree_tol = 1e-3                # Brownian tree tolerance
sde_pid_rtol = 1e-3                         # Relative tolerance for PID controller
sde_pid_atol = 1e-6                         # Absolute tolerance for PID controller
sde_pid_dtmin = 1e-5                        # Minimum time step
sde_pid_dtmax = 0.1                         # Maximum time step
sde_solver_type = "heun"                    # Solver type: "euler" or "heun"
sde_initial_dt_factor = 10.0                # Safety factor for dt0 calculation (dtmax / factor)

# Kernel B (DGM - Deep Galerkin Method for HJB PDE)
dgm_width_size = 64                     # Hidden layer width for DGM network
dgm_depth = 4                           # Number of hidden layers
dgm_entropy_num_bins = 50               # Histogram bins for entropy monitoring
dgm_activation = "tanh"                 # Activation function: "tanh" (smooth PDEs), "relu", "elu", "gelu"
kernel_b_r = 0.05                       # Drift rate parameter (HJB Hamiltonian)
kernel_b_sigma = 0.2                    # Dispersion coefficient (HJB diffusion term)
kernel_b_horizon = 1.0                  # Prediction horizon (integration time)
kernel_b_spatial_samples = 100          # Number of spatial sample points for entropy computation
kernel_b_spatial_range_factor = 0.5     # Spatial sampling range factor (±factor around current_state)

[io]
# Data feed parameters (domain-agnostic: applies to any external data source)
data_feed_timeout = 30  # seconds
data_feed_max_retries = 3

# Frozen signal policy
frozen_signal_min_steps = 5
frozen_signal_recovery_ratio = 0.1
frozen_signal_recovery_steps = 2

# Snapshot parameters
snapshot_atomic_fsync = true
snapshot_compression = "none"  # or "gzip", "brotli"
snapshot_format = "msgpack"  # or "protobuf"
snapshot_hash_algorithm = "sha256"  # or "crc32c"

# Telemetry
telemetry_hash_interval_steps = 1
telemetry_buffer_capacity = 1024  # Maximum capacity of telemetry buffer (zero-heuristics injection)

[validation]
# Phase 5: Zero-Heuristics Validation Constraints
# All hardcoded defaults have been eliminated and moved to config-driven parameters

# Finite value validation (NaN/Inf detection)
validation_finite_allow_nan = false         # Permit NaN values?
validation_finite_allow_inf = false         # Permit Inf values?

# Simplex constraint validation (weights sum to 1.0)
validation_simplex_atol = 1e-6              # Absolute tolerance for sum check

# Holder exponent range validation
validation_holder_exponent_min = 0.0        # Min Holder exponent
validation_holder_exponent_max = 1.0        # Max Holder exponent

# Alpha-stable parameter validation
validation_alpha_stable_min = 0.0           # Min alpha (stability parameter)
validation_alpha_stable_max = 2.0           # Max alpha (stability parameter)
validation_alpha_stable_exclusive_bounds = true  # Use strict inequalities?

# Beta (skewness) parameter validation
validation_beta_stable_min = -1.0           # Min beta (skewness parameter)
validation_beta_stable_max = 1.0            # Max beta (skewness parameter)

# Array sanitization policies
sanitize_replace_nan_value = 0.0            # Default NaN replacement value
# sanitize_replace_inf_value = null         # Replacement for Inf (null = preserve Inf)
# sanitize_clip_range = null                # Tuple [min, max] for clipping (null = no clipping)