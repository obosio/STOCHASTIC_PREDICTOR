\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{geometry}
\usepackage{array}
\usepackage[hidelinks]{hyperref}

\geometry{a4paper, margin=1in}

\title{Especificación de Interfaz de Entrada/Salida (I/O) - Sistema de Predictores Universales}
\author{Arquitectura de Sistemas}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Resumen Ejecutivo}
Este documento define la interfaz abstracta de Entrada/Salida (I/O) para el Sistema de Predictores Universales, independiente de su implementación específica (Python/JAX, C++, Rust, FPGA). Describe los vectores de configuración necesarios para instanciar el sistema, el flujo de datos en tiempo de ejecución y la estructura de las señales de salida y telemetría.

\section{Vector de Configuración (Hyper-Inputs)}
El sistema se inicializa mediante un vector de configuración $\Lambda$ que define la topología y sensibilidad de los módulos. Estos parámetros suelen ser estáticos durante la sesión de operación o calibrados por un meta-optimizador externo.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|l|}
\hline
\textbf{Parámetro} & \textbf{Símbolo} & \textbf{Descripción Funcional} \\
\hline
Regularización Entrópica & $\epsilon$ & Suavizado del transporte de masa en el Orquestador JKO (Sinkhorn). \\
Tasa de Aprendizaje & $\tau$ & Velocidad de adaptación de los pesos $\rho$ ante gradientes de energía. \\
Profundidad de Firma & $L$ & Grado de trunqueo de la Log-Signature (Kernel D - Topológico). \\
Memoria WTMM & $N_{buf}$ & Tamaño de la ventana deslizante para estimar singularidades. \\
Cono de Besov & $C_{besov}$ & Radio de influencia para el seguimiento de máximos en ondelettes. \\
Umbral de Hölder & $H_{min}$ & Valor crítico de regularidad que activa el \textit{Circuit Breaker}. \\
Umbral CUSUM & $h$ & Nivel de desviación acumulada que dispara el reinicio de pesos. \\
Slack CUSUM & $k$ & Tolerancia a la deriva ("ruido blanco") permitida sin acumular error. \\
Memoria de Volatilidad & $\alpha$ & Tasa de decaimiento (EMA) para estimar la varianza del error. \\
\hline
\end{tabular}
\caption{Vector de Hiperparámetros $\Lambda$}
\end{table}

\section{Flujo de Entrada (Data Injection)}

\subsection{1. Fase de Calibración (Bootstrapping)}
Estado inicial requerido antes de la operación secuencial.

\textbf{Entrada:} Historia $\mathcal{H} = \{y_{-T}, \dots, y_0\}$
\begin{itemize}
    \item \textbf{Estructura:} Serie temporal de vectores $\mathbf{y} \in \mathbb{R}^d$ o escalares $y \in \mathbb{R}$.
    \item \textbf{Propósito:}
    \begin{itemize}
        \item Inicialización de núcleos dependientes de historia (ej. parámetros de Lévy).
        \item Estabilización de los pesos iniciales $\rho_0$ del orquestador.
        \item Llenado del búfer de singularidad para el módulo WTMM.
    \end{itemize}
\end{itemize}

\subsection{2. Fase Operativa (Online Stream)}
Ciclo de actualización paso a paso en tiempo $t$.

\textbf{Entrada del Paso $t$:} Tupla $(y_t, y_{target}, \tau_{epoch})$
\begin{itemize}
    \item \textbf{Marca de Tiempo ($\tau_{epoch}$):} Timestamp absoluto (Unix Nanoseconds). Obligatorio para sincronización y cálculo de latencia en la política de abandono.
    \item \textbf{Observación Actual ($y_t$):} 
    \begin{itemize}
        \item El nuevo dato disponible en $t$.
        \item Se utiliza para alimentar los núcleos ($K_A, K_B, K_C, K_D$) y generar las predicciones para $t+1$.
        \item \textbf{Gestión de Errores de Dominio:} Si $|y_t| > 20\sigma$ (respecto a la normalización histórica), el dato se clasifica como \textit{Outlier Catastrófico}. El sistema debe descartar la entrada, mantener el estado inercial y emitir una alerta crítica de validación, protegiendo los núcleos de divergencia numérica.
    \end{itemize}
    \item \textbf{Malla de Inferencia (Anti-Aliasing Input):}
    \begin{itemize}
        \item \textbf{Frecuencia de Muestreo vs Escalas ($N_{buf}$):} Para garantizar la estabilidad del análisis WTMM (Singularidades del Kernel D), la frecuencia de inyección de datos debe mantener una densidad suficiente respecto a las escalas wavelet más finas.
        \item \textit{Restricción:} Se impone una \textbf{Frecuencia Mínima de Inyección} (Nyquist soft-limit) dependiente de $C_{besov}$. Si la densidad de eventos cae por debajo de este umbral, el espectro multifractal colapsará, y el sistema debe congelar la actualización de la rama topológica.
    \end{itemize}

    \item \textbf{Objetivo de Validación ($y_{target}$):}
    \begin{itemize}
        \item El valor "real" correspondiente a la predicción generada en el paso anterior ($t-1$).
        \item Generalmente $y_{target} \equiv y_t$ (en predicción one-step-ahead causal).
        \item Se utiliza para calcular el error $e_t = y_{target} - \hat{y}_{t|t-1}$ y calcular el gradiente de energía $\nabla E$ para el transporte JKO.
    \end{itemize}

    \item \textbf{Métrica de Abandono (Staleness Policy):}
    \begin{itemize}
        \item \textbf{Tiempo de Vida (TTL):} Parámetro $\Delta_{max}$.
        \item \textbf{Comportamiento ante Violación:} Si el retraso de $y_{target}$ excede $\Delta_{max}$, la actualización JKO se cancela.
        \item \textbf{Señal de Integridad:} El sistema debe emitir una bandera persistente de \textit{Inferencia Degradada} ("Stale Weights"). Esto alerta al ejecutor de que, aunque la predicción $\hat{y}$ sigue generándose, los pesos $\rho$ tienen inercia obsoleta y el riesgo ya no está siendo optimizado geométricamente.
    \end{itemize}
\end{itemize}

\section{Salidas del Sistema (System Outputs)}

\subsection{1. Señal de Control (Prediction Signal)}
La salida primaria para la toma de decisiones.

\textbf{Salida:} $\hat{y}_{t+1}$
\begin{itemize}
    \item \textbf{Descripción:} Estimación del valor esperado del proceso para el siguiente instante.    \item \textbf{Malla de Inferencia (Output Quantization):}
    \begin{itemize}
        \item La salida $\hat{y}_{t+1}$ se entrega en el espacio normalizado (Z-Score) consistente con la entrada $y_t$.
        \item El Actor/Ejecutor es responsable de aplicar la transformación inversa (des-normalización) utilizando las estadísticas de ventana rodante si se requiere un precio absoluto.
    \end{itemize}
    \item \textbf{Composición:} Combinación convexa de los núcleos base: $\hat{y}_{t+1} = \sum_{i \in \{A,B,C,D\}} \rho_i^{(t)} \cdot K_i(y_t)$.
\end{itemize}

\subsection{2. Indicadores de Estado (State Telemetry)}
Variables latentes que describen la "salud" y el régimen del mercado.

\begin{itemize}
    \item \textbf{Estado de Riesgo ($\mathbb{S}_{risk}$):}
    \begin{itemize}
        \item \textbf{Exponente de Hölder local ($H_t$):} Medida de regularidad puntual. $H_t < 0.5$ indica antipersistencia/ruido; $H_t < H_{min}$ indica crash/shock inminente.
        
        \item \textbf{Curtosis Empírica ($\kappa_t$):} Cuarto momento estandarizado de los residuos de predicción sobre ventana móvil:
        \[
        \kappa_t = \frac{E[(e_t - \mu_e)^4]}{(\sigma_e)^4}
        \]
        donde $e_t = y_{target} - \hat{y}_{t|t-1}$ son los residuos de predicción.
        \begin{itemize}
            \item \textbf{Propósito:} Validar la idoneidad del umbral CUSUM adaptativo. Valores $\kappa_t > 3$ indican distribución leptocúrtica (colas pesadas), lo cual activa el ajuste logarítmico del umbral $h_t = k \cdot \sigma \cdot (1 + \ln(\kappa_t/3))$.
            \item \textbf{Interpretación:} $\kappa_t \approx 3$ (Gaussiano), $\kappa_t \in [5, 10]$ (régimen de volatilidad financiera estándar), $\kappa_t > 15$ (régimen de crisis con eventos extremos frecuentes).
            \item \textbf{Alerta:} Si $\kappa_t > 20$ de forma persistente, emitir advertencia de posible falla en el modelo de residuos o presencia de outliers sistemáticos no detectados.
        \end{itemize}
        
        \item \textbf{Entropía del Predictor DGM ($H_{DGM}$):} Entropía diferencial de la distribución de valores de la función valor neuronal $V_\theta(t,x)$ sobre el dominio espacial:
        \[
        H_{DGM} = -\int p_V(v) \log p_V(v) \, dv
        \]
        donde $p_V(v)$ es la densidad empírica de valores de $V_\theta$ evaluados en una malla de puntos del dominio.
        \begin{itemize}
            \item \textbf{Propósito:} Monitorizar la salud de la Rama B (solución HJB mediante Deep Galerkin Method) y detectar colapso de modo donde la red neuronal predice una solución constante o degenerada.
            \item \textbf{Umbral de Colapso:} Se debe comparar contra la entropía de la condición terminal: $H_{DGM} \geq \gamma \cdot H[g]$ con $\gamma \in [0.5, 1.0]$. Si la desigualdad se viola persistentemente (más de 10 pasos consecutivos), emitir \texttt{ModeDegradationAlert}.
            \item \textbf{Acción Correctiva:} Reducir el peso de la Rama B en el orquestador ($\rho_B \to 0$) y priorizar ramas alternativas hasta que se re-entrene la red DGM o se reinicializen sus pesos.
            \item \textbf{Nota:} Este indicador solo es relevante si la Rama B está activa ($\rho_B > 0.05$). Para sistemas que no utilizan DGM, este campo puede omitirse o reportarse como \texttt{NaN}.
        \end{itemize}
        
        \item \textbf{Estadístico CUSUM ($G^+$):} Nivel de desajuste estructural acumulado.
        
        \item \textbf{Distancia al Colapso ($h_t - G^+$):} Margen de seguridad restante antes de un reinicio forzado del modelo. Nota: $h_t$ es ahora dinámico y depende de $\sigma_t$ y $\kappa_t$.
        
        \item \textbf{Energía Libre Residual ($\mathcal{F}$):} Valor instantáneo del funcional de JKO. Monitoriza si el modelo está "atrapado" en un mínimo local estable o si la regularización entrópica $\epsilon$ es demasiado alta, diluyendo excesivamente la capacidad predictiva del transporte de masa.
    \end{itemize}
    
    \item \textbf{Estado del Orquestador ($\rho$):}
    \begin{itemize}
        \item \textbf{Vector de Pesos:} $[\rho_A, \rho_B, \rho_C, \rho_D]$ tal que $\sum \rho = 1$.
        \item Indica qué "física" domina actualmente el mercado (Saltos vs Difusión vs Memoria vs Topología).
    \end{itemize}

    \item \textbf{Health-Check Estocástico:}
    \begin{itemize}
        \item \textbf{Convergencia Sinkhorn (Bool):} Indica si el algoritmo de transporte de masa convergió dentro del número máximo de iteraciones.
        \item \textit{True:} Distancia Wasserstein exacta. \textit{False:} Aproximación sub-óptima (alerta de precisión numérica).
    \end{itemize}
    
    \item \textbf{Flags de Operación (Modo y Circuit Breakers):}
    \begin{itemize}
        \item \textbf{Modo de Operación Base:}
        \begin{itemize}
            \item \textit{Standard (MSE):} Operación normal bajo supuestos Gaussianos locales.
            \item \textit{Robust (Huber):} Operación defensiva activada por singularidades ($H_t < H_{min}$) o alta volatilidad.
        \end{itemize}
        
        \item \textbf{Modo de Inferencia Degradada (Degraded Inference Mode):} Flag booleano crítico para monitoreo de calidad temporal:
        \begin{itemize}
            \item \textbf{Condición de Activación:} Se activa cuando el Time-To-Live (TTL) de la señal $y_{target}$ excede el umbral máximo permitido:
            \[
            \text{TTL}(y_{target}) = t_{current} - t_{signal} > \Delta_{max}
            \]
            \item \textbf{Implicaciones Operacionales:}
            \begin{enumerate}
                \item La actualización del transporte JKO se suspende inmediatamente
                \item Los pesos $\rho$ se congelan en su último valor válido (modo inercial)
                \item Las predicciones $\hat{y}_{t+1}$ continúan generándose, pero son sub-óptimas pues no reflejan el estado real del mercado
                \item El riesgo ya NO está siendo optimizado geométricamente
            \end{enumerate}
            \item \textbf{Señalización al Ejecutor:} Este flag debe alertar explícitamente que:
            \begin{itemize}
                \item Las predicciones actuales tienen \textit{confianza degradada}
                \item Los pesos son obsoletos (stale weights)
                \item Se recomienda reducir exposición o operar en modo conservador
                \item El sistema opera en "modo supervivencia" hasta que se restablezca el flujo de datos frescos
            \end{itemize}
            \item \textbf{Recuperación:} El flag se desactiva automáticamente cuando se recibe una señal fresca con $\text{TTL}(y_{target}) < 0.8 \cdot \Delta_{max}$ (umbral con histéresis para evitar oscilaciones). En ese momento se reanuda el transporte JKO y se emite \texttt{NormalOperationRestoredEvent}.
        \end{itemize}
        
        \item \textbf{Emergency Mode (Singularity Fallback):} Flag que indica si se activó el modo de emergencia por singularidad crítica ($H_t < H_{min}$), forzando $w_D \to 1.0$ y cambiando a métrica de Huber.
        
        \item \textbf{Regime Change Detected:} Flag que indica si CUSUM detectó un cambio de régimen en el último paso, con reinicio de entropía a distribución uniforme.
    \end{itemize}
\end{itemize}

\section{Diagrama de I/O Abstracto}

\[
\boxed{\text{Entorno}} \xrightarrow{(y_t, y_{target})} \boxed{\text{Predictor Universal}(\Lambda)} \xrightarrow{(\hat{y}_{t+1}, \mathbb{S}_{risk}, \rho)} \boxed{\text{Actor / Ejecutor}}
\]

\subsection{Ciclo de Proceso Interno}
\begin{enumerate}
    \item \textbf{Ingesta:} Recibir $y_t$. Actualizar historial local.
    \item \textbf{Análisis de Singularidad:} Calcular $H_t$ usando WTMM sobre ventana reciente.
    \item \textbf{Control de Calidad (CUSUM):} 
        \begin{itemize}
            \item Calcular error $e_t$ usando $y_{target}$ y la predicción almacenada $\hat{y}_{t|t-1}$.
            \item Actualizar acumulador de deriva $G^+$.
            \item Si $G^+ > h$ o $H_t < H_{min}$ $\rightarrow$ Emitir señal de reinicio/alerta.
        \end{itemize}
    \item \textbf{Transporte (JKO):}
        \begin{itemize}
            \item Calcular gradiente de energía $\nabla E$ basado en $e_t$.
            \item Transportar masa de probabilidad $\rho_{t-1} \to \rho_t$ (Sinkhorn).
        \end{itemize}
    \item \textbf{Proyección:}
        \begin{itemize}
            \item Ejecutar núcleos $K_i(y_t)$ para obtener componentes.
            \item Agregar componentes usando nuevos pesos $\rho_t$ para obtener $\hat{y}_{t+1}$.
        \end{itemize}
\end{enumerate}

\section{Persistencia (Snapshotting)}
Para garantizar la continuidad operativa, el sistema debe ser capaz de serializar su estado interno completo $\Sigma_t$ en cualquier instante $t$.

\[
\Sigma_t = \{ \rho_t, G^+_t, \sigma^2_{ema}, \kappa_t, H_{DGM}, \text{Flags}, \text{Búfer}_{WTMM}, \text{KernelsState} \}
\]

donde:
\begin{itemize}
    \item $\kappa_t$: Curtosis empírica móvil de los errores de predicción (window size = 252).
    \item $H_{DGM}$: Entropía diferencial del predictor DGM (para detección de mode collapse).
    \item \texttt{Flags}: Estructura de flags booleanos que incluye \texttt{DegradedInferenceMode}, \texttt{EmergencyMode}, y \texttt{RegimeChangeDetected}.
\end{itemize}

La estructura \texttt{KernelsState} se debe segmentar en sub-bloques independientes (K-Blocks) para permitir actualizaciones modulares o parciales:
\[
\text{KernelsState} = \{ S_A (\text{Lévy}), S_B (\text{PDE}), S_C (\text{Memoria}), S_D (\text{Topología}) \}
\]

La operación de restauración $Load(\Sigma_t)$ debe permitir reanudar el flujo en $t+1$ sin necesidad de re-calibración sobre la historia $\mathcal{H}$. La correcta restauración de $\kappa_t$ y $H_{DGM}$ es crítica para preservar la capacidad de detección de anomalías y mode collapse tras un reinicio.

\subsection{Protocolo de Snapshotting Atómico y Verificado}
Se exige el uso de formatos de serialización binaria (ej. Protocol Buffers, MessagePack) en lugar de texto (JSON/XML) para el almacenamiento de $\Sigma_t$. Esto minimiza la latencia de I/O en operaciones de "Hot-Start" críticas.

\begin{itemize}
    \item \textbf{Integridad Obligatoria (Mandatory Checksum):} Dado que se utilizan formatos binarios densos, un error de un solo bit en el estado de las matrices de los núcleos o el búfer WTMM podría provocar un colapso del sistema o comportamiento indefinido. Por tanto, la estructura $\Sigma_t$ debe incluir un hash de validación robusto (ej. SHA-256 o CRC32c) al final del bloque.
    \item \textbf{Validación Pre-Inyección:} La rutina de restauración $Load(\Sigma_t)$ debe recalcular y validar este hash \textit{antes} de inyectar el estado en la memoria operativa. Si la validación falla, el snapshot debe descartarse y el sistema debe reiniciarse en modo "Cold-Start" (recarga de historia).
\end{itemize}

\end{document}
